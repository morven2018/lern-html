<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Нотация описания архитектуры приложения</title>
</head>

<body>
    <h1>Нотация описания архитектуры приложения</h1>
    <h2>Мотивация</h2>

    <p>Я, как технический директор, регулярно сталкиваюсь с необходимостью обсудить с командой архитектуру нового
        приложения
        или микросервиса. И в рамках таких обсуждений я понял, что не существует единого подхода, который позволил бы
        эффективно
        общаться команде, обсуждая архитектурные решения.</p>

    <p>Понятно, что на словах это не объяснишь и приходится прибегать к дополнительным инструментам в виде доски и
        маркера
        или
        же при текущих реалиях - online доски типа <a href="https://miro.com/ru/" target="_blank">Miro</a> Но даже в
        этом случае
        обсуждение сваливается в хаотично
        нарисованные
        квадратики, круги или прямоугольники с текстом, как-то соединённые стрелками.</p>

    <p>При этом от обсуждения к обсуждению одна и так же схема может быть нарисована 1000 разными способами. Кто-то в
        творческом порыве начинает рисовать иконки пользователей или серверов, а кто-то рисует поток из 10 стрелок,
        чтобы
        показать все возможные варианты взаимодействия. И это - не эффективная коммуникация, где одно и тоже можно
        понять
        по-разному при этом потратив какое-то время на пояснение чем шестиугольник отличается круга.</p>

    <h2>А что есть?</h2>
    <p>Осознав проблемы я первым делом начал искать готовые варианты. Вот несколько из них:</p>


    <ul>
        <li>Диаграмма классов - иногда бывает удобной для анализа уже существующего кода, но не применима для
            изначального
            проектирования, где мы оперируем более верхне уровневыми объектами.</li>
        <li>c4model - уже ближе к теме и предлагает 4 уровня детализации схемы программного обеспечения. Но часто из
            всех 4-х
            уровней подходит 3-й, когда мы планируем новый сервис, а на 3-м уровне стандартов описания немного. Отлично
            подходит для
            верхнего уровня описания системы, но при детализации на компоненты не имеет детальных стандартов.</li>
    </ul>


    <p>Потому после нескольких экспериментов, я решил подготовить простую нотацию, которая позволит описать архитектуру
        приложений на том уровне, чтобы мы могли:</p>
    <ul>
        <li>Разбить создание его на задачи.</li>
        <li>Проверить корректность деления на модули, чтобы сократить их связанность.</li>
        <li>Упростить коммуникацию в команде при обсуждении деталей проектирования приложения.</li>
        <li>Использовать её для документирования архитектуры как монолита, так и микросервисов.</li>
    </ul>



    <h2>Требования к нотации</h2>
    <p>Перед тем, как переходить к описанию предлагаемой нотации следует сформулировать требования, которым она должна
        удовлетворять:</p>

    <ul>
        <li>Она должна на верхнем уровне описывать отделимые части системы, которые далее я буду назвать «компоненты».
        </li>
        <li>Связи между ними должны описать зависимости и поток вызовов, но не быть слишком усложнены. По связям должно
            быть сразу
            понятно наличии архитектурных ошибок.</li>
        <li>Схема должна подходить как для описания монолитного приложения, так и микросервисной архитектору.</li>
        <li>Фокус должен быть на описании нашей архитектуры, максимально абстрагировавшись от внешних систем.</li>
    </ul>

    <p>Ниже будет написано мое видение такой нотации с учётом опыта тестирования её вместе с командой. На практике она
        позволила в кратчайшие сроки обсуждать изменения в архитектуре или планировать полноценные новые сервисы или
        приложения.</p>

    <!--fgvbf-->

    <h2>Структура диаграммы</h2>
    <p>В первую очередь давайте перечислим все возможные блоки, которые могут использоваться в диаграмме:</p>
    <ul>
        <li>Приложения - отделимые приложения для описания микросервисного подхода.</li>
        <li>Модули - объединяют компоненты.</li>
        <li>Компоненты - основные строительные блоки приложения.</li>
        <li>Внутренние связи между компонентами - обозначение связей между компонентами.</li>
        <li>Внешние связи - с другими системами или между микросервисами.</li>
        <li>Передаваемые объекты - между компонентами системы или вне</li>
        <li>Детализация полей, которые могут быть детальным описанием свойств, методов и структуры данных.</li>
    </ul>


    <h2>Компоненты</h2>

    <p>Стоит начать рассмотрение именно с компонент, так как они являются строительными блоками всей нашей диаграммы.
        Это
        изолированный с точки зрения логики кусок кода, который может в реальности представлять собой класс или
        отдельный
        файл.</p>

    <p>Это может быть:</p>

    <ul>
        <li>Контроллер, которые обрабатывает входящие запросы.</li>
        <li>Сервис, отвечающий за бизнес логику работы с платежами.</li>
        <li>Репозиторий, взаимодействующий с базой данных.</li>
        <li>Обработчик event событий при использовании event sourcing.</li>
        <li>Бизнес entity пользователя, содержащие поля для него и методы работы.</li>
    </ul>


    <p>Фактически все, что вы можете выделить в виде класса с инкапсулированной логикой - это компонент.</p>

    <p> Для того чтобы максимально полно описать компонент можно указать следующие параметры:</p>

    <ul>
        <li>Имя - название компонента, отражающие его суть или даже название класса</li>
        <li>Тип - чтобы понять что это контроллер или репозиторий</li>
        <li>Пояснение - если требуется дополнительное описание.</li>
    </ul>


    <p>Примеры:</p>
    <img src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image1.jpg" alt="Примеры 1">

    <h2>Внутренние связи</h2>

    <p>Неразрывной стрелкой показываются связи между компонентами системы. При этом, направление стрелки указывает
        направление
        зависимости (вызова методов). Если комплект UserContoller требует вызова метода из UserService:</p>
    <p>При этом связь не указывает поток передачи данных, чтобы не усложнять диаграмму.</p>
    <p>Двунаправленный стрелки возможны, но это будут обозначать круговую зависимость, которую следует избегать.</p>
    <p>На стрелке можно дополнительно указать название метода, который будет вызываться, если это важно:</p>

    <img src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image2.jpg" alt="пример2">

    <h2>Внешние связи</h2>

    <p>Пунктирной стрелкой обозначится входящее или исходящее сообщение, или событие в / из внешней системой. Это может
        быть
        API вызов, сообщения через шину RMQ в другие части системы, запрос в базу данных или интеграция с внешним API.
    </p>
    <p>В описании можно дать:</p>
    <ul>
        <li>Название команды</li>
        <li>Тип запроса</li>
        <li>Название внешнего сервиса.</li>
    </ul>
    <p>Примеры:</p>
    <img src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image3.jpg" alt="пример3">

    <h2>Модули</h2>

    <p>В свою очередь компоненты группируются в отделимые друг от друга модули. Модуль должен проектироваться таким
        образом,
        чтобы вобрать в себя компоненты, которые относятся к одной доменной области.</p>

    <p>Например, репозиторий работы с пользованием, entity пользователя и контроллер, который обрабатывает запросы на
        добавления пользователя в базу.</p>

    <p>В идеале модуль должен быть сделан так, чтобы его можно было бы легко вытащить из приложения и выделить например
        в
        отдельный микросервис.</p>

    <p>Модульности может меняться от одного архитектурного подхода к другому. Например, для Nest.js или Angular уже есть
        такое
        понятие как модуль, а для React модулем может выступать папка, в которой группированы те или иные компоненты.
        Для С# это
        может быть Namespace или логически выделенный кусок приложения.</p>

    <p>Модули имеют лишь название и группируют внутри себя компоненты отображая свои границы:</p>

    <img src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image4.jpg" alt="пример4">

    <p>Связи между компонентами могут проходить через границы модулей, что будет означать зависимость одного модуля от
        другого.
        И снова при наличии связей в оба направления можно сказать, что и модули имеют круговую зависимость друг от
        друга и
        возможно композицию состоит пересмотреть.</p>

    <h2>Приложения</h2>
    <p>Если система, которую вы хотите описать состоит не из одного приложения, а из нескольких, можно использовать
        обертку
        приложения, которое объединяет в себя модули. Пунктирными стрелками отмечаются связи между ними, как если бы они
        были
        внешним системами по отношению к друг-другу. Аналогично можно добавить описание и протокол взаимодействия.</p>

    <img src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image5.jpg" alt="пример 5">

    <p>Но тут следует заметить, что если в текущем обсуждении архитектура одного из микросервисов не важна, лучше
        оставить его
        просто внешней зависимостью, не детализируя архитектуру. Это упростит и ускорит описание.</p>
    <h2>Передаваемые объекты</h2>
    <p>При передаче данных между компонентами системы, может возникнуть необходимость описать их структуру. Обычно такие
        объекты носят название DTO (data transfer object). Они обозначаются прямоугольниками с закруглёнными на 50%
        углами.
        Можно добавить не только название DTO, но и его тип: event, query, command.</p>

    <img src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image6.jpg" alt="пример6">

    <h2>Детализация</h2>

    <p>Большинство приложений, который мы пишем так или иначе содержат внешние зависимости и библиотеки. Для вашего
        приложения
        вы можете добавить список зависимостей, которые влияют на выбор архитектуры. Это делается с помощью компонента
        детализации, который является простым списком.</p>

    <p>Так же, если в рамках вашей архитектуры вам важно детально описать поля базы данных, или какой-либо объекта вы
        тоже
        можете воспользоваться детализацией.</p>


    <p>При этом если для вашего обсуждения детализация не нужна, не тратьте на неё время.</p>

    <img src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image7.jpg" alt="пример 7">

    <h2>Пример</h2>
    <p>Для того чтобы проиллюстрировать работу нотации на примере, давайте возьмём упрощенный клон MailChimp, который
        позволяет
        формировать списки пользователей для рассылки и отправлять им письма. Обращаю ваше внимание, что для примера вся
        система
        описана целиком. В реальности большую систему таким образом будет описать очень проблематично, так как это
        займёт много
        времени. Поэтому я рекомендую использовать диаграммы для обсуждения конкретного решения проблемы или
        первоначальной
        архитектуры. Но даже на этом примере можно проследить использование всех компонент.</p>

    <p>У нас есть API, в которое приходят запросы по кампаниями и подписчикам. Мы планируем реализовать микросервисную
        архитектуру с централизованным API.</p>

    <p>Отдельно у нас есть сервис работы с кампаниями, который содержит базу данных с подписчиками и их списками, а так
        же
        сервис внешней интеграции с SendGrid, который и будет отправлять письма. Вот так будет выглядеть <a
            href="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image8.jpg"
            target="_blank"> схема приложения:</a></p>

    <img src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image8.jpg" alt="">
    <p>Она специально сделана детально, чтобы показать все возможности. Мы описали все возможные роуты, структуры баз,
        логику
        разбивки на модули. Отдельно выделил сложную сагу, которая призвана управлять логикой отправки кампании (можно
        было
        реализовать и по иному, в данном случае - это пример одной из возможных реализаций).</p>

    <h2>Использование</h2>
    <p>Вы можете использовать эту нотацию в любом удобном для вас инструменте, например draw.io или visio. Но для
        удобства я
        подготовил для вас готовую библиотеку в Figma, которая позволит быстро рисовать диаграммы, добавляя компоненты
        из
        библиотеки. Вы можете <a
            href="https://www.figma.com/community/file/1076518826949849808/Software-Architecture-Components"
            target="_blank"> скачать её тут</a>. После открытия ссылки нажмите на Duplicate и получите готовую
        библиотеку у себя в
        figma. Перейдя на вкладку Assets вы получите готовые компоненты, которые можете перетаскивать и изменять по
        своему
        желанию.</p>

    <p>Так же в этом файле есть описанный выше пример, составленный из компонент, где вы можете рассмотреть его
        подробнее.</p>
    <p>Надеюсь эта нотация пригодиться и вам!</p>
</body>



</html>
<h1>Нотация описания архитектуры приложения</h1>
<h2>Мотивация</h2>

<p>Я, как технический директор, регулярно сталкиваюсь с необходимостью обсудить с командой архитектуру нового приложения
    или микросервиса. И в рамках таких обсуждений я понял, что не существует единого подхода, который позволил бы
    эффективно
    общаться команде, обсуждая архитектурные решения.</p>

<p>Понятно, что на словах это не объяснишь и приходится прибегать к дополнительным инструментам в виде доски и маркера
    или
    же при текущих реалиях - online доски типа Miro. Но даже в этом случае обсуждение сваливается в хаотично
    нарисованные
    квадратики, круги или прямоугольники с текстом, как-то соединённые стрелками.</p>

<p>При этом от обсуждения к обсуждению одна и так же схема может быть нарисована 1000 разными способами. Кто-то в
    творческом порыве начинает рисовать иконки пользователей или серверов, а кто-то рисует поток из 10 стрелок, чтобы
    показать все возможные варианты взаимодействия. И это - не эффективная коммуникация, где одно и тоже можно понять
    по-разному при этом потратив какое-то время на пояснение чем шестиугольник отличается круга.</p>

А что есть?
Осознав проблемы я первым делом начал искать готовые варианты. Вот несколько из них:

Диаграмма классов - иногда бывает удобной для анализа уже существующего кода, но не применима для изначального
проектирования, где мы оперируем более верхне уровневыми объектами.
c4model - уже ближе к теме и предлагает 4 уровня детализации схемы программного обеспечения. Но часто из всех 4-х
уровней подходит 3-й, когда мы планируем новый сервис, а на 3-м уровне стандартов описания немного. Отлично подходит для
верхнего уровня описания системы, но при детализации на компоненты не имеет детальных стандартов.
Потому после нескольких экспериментов, я решил подготовить простую нотацию, которая позволит описать архитектуру
приложений на том уровне, чтобы мы могли:

Разбить создание его на задачи.
Проверить корректность деления на модули, чтобы сократить их связанность.
Упростить коммуникацию в команде при обсуждении деталей проектирования приложения.
Использовать её для документирования архитектуры как монолита, так и микросервисов.
Требования к нотации
Перед тем, как переходить к описанию предлагаемой нотации следует сформулировать требования, которым она должна
удовлетворять:

Она должна на верхнем уровне описывать отделимые части системы, которые далее я буду назвать «компоненты».
Связи между ними должны описать зависимости и поток вызовов, но не быть слишком усложнены. По связям должно быть сразу
понятно наличии архитектурных ошибок.
Схема должна подходить как для описания монолитного приложения, так и микросервисной архитектору.
Фокус должен быть на описании нашей архитектуры, максимально абстрагировавшись от внешних систем.
Ниже будет написано мое видение такой нотации с учётом опыта тестирования её вместе с командой. На практике она
позволила в кратчайшие сроки обсуждать изменения в архитектуре или планировать полноценные новые сервисы или приложения.

Структура диаграммы
В первую очередь давайте перечислим все возможные блоки, которые могут использоваться в диаграмме:

Приложения - отделимые приложения для описания микросервисного подхода.
Модули - объединяют компоненты.
Компоненты - основные строительные блоки приложения.
Внутренние связи между компонентами - обозначение связей между компонентами.
Внешние связи - с другими системами или между микросервисами.
Передаваемые объекты - между компонентами системы или вне
Детализация полей, которые могут быть детальным описанием свойств, методов и структуры данных.
Компоненты
Стоит начать рассмотрение именно с компонент, так как они являются строительными блоками всей нашей диаграммы. Это
изолированный с точки зрения логики кусок кода, который может в реальности представлять собой класс или отдельный файл.

Это может быть:

Контроллер, которые обрабатывает входящие запросы.
Сервис, отвечающий за бизнес логику работы с платежами.
Репозиторий, взаимодействующий с базой данных.
Обработчик event событий при использовании event sourcing.
Бизнес entity пользователя, содержащие поля для него и методы работы.
Фактически все, что вы можете выделить в виде класса с инкапсулированной логикой - это компонент.

Для того чтобы максимально полно описать компонент можно указать следующие параметры:

Имя - название компонента, отражающие его суть или даже название класса
Тип - чтобы понять что это контроллер или репозиторий
Пояснение - если требуется дополнительное описание.